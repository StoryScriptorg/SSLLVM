# LLVM IR Builder
from llvmtypes import int_integer, float_float
import orjson
from colorama import init, Fore, Back, Style
from mathParser.mathProcessor import process as process_expression

init()


class IRBuilder:
    """
    An LLVM IR builder.
    """

    def __init__(self, module_name: str):
        self.module_name = module_name
        self.footer = ""
        self.function_imported = set()
        self.main_function = ""
        self.header = ""

    def define_string(self):
        pass

    def print_message(self, message):
        if not "puts" in self.function_imported:
            self.footer += "declare i32 @puts(i8*)"
            self.function_imported.add("puts")
        self.header += f'@.gtempstr_{len(self.main_function)} = private unnamed_addr constant [{len(message) + 1} x i8] c"{message}\\00"\n'
        self.main_function += f"%temp_str_{len(self.main_function)} = getelementptr [{len(message) + 1} x i8], [{len(message) + 1} x i8]* @.gtempstr_{len(self.main_function)}, i32 0, i32 0\n\tcall i32 @puts(i8* %temp_str_{len(self.main_function)})\n"

    def buildIR(self):
        lb = "{"
        rb = "}"
        ir = f"""; ModuleID = \"{self.module_name}\"
; LLVM IR generated by SSLLVM

{self.header}

define i32 @main() {lb}
entry:
	{self.main_function}
	ret i32 0
{rb}

{self.footer}
"""
        return ir


# How many time the build IR function has run, Use to make a unique module name
runtimes = 0


def buildIRFromCache(commands: list):
    """Build LLVM IR from StoryScript Cache"""
    irb = IRBuilder(f"main")
    for i in commands:
        tc = i.split()
        if tc[0] == "CALL":
            if tc[1] == "print":
                irb.print_message(" ".join(tc[2:]))
    return irb.buildIR()


def buildIRFromSource(commands: list):
    """Build LLVM IR from Source code directly."""
    pass
